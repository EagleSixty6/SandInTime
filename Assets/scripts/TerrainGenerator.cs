using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

using ImprovedPerlinNoiseProject;

public class TerrainGenerator : MonoBehaviour
{
    //There are 8 threads run per group so N must be divisible by 8.
    private const int NUM_OF_THREADS = 8;
    
    //The size of the voxel array for each dimension
    const int N = 64;

    //The size of the buffer that holds the verts.
    //This is the maximum number of verts that the 
    //marching cube can produce, 5 triangles for each voxel.
    const int SIZE = N * N * N * 3 * 5;
    
    public int _seed;
    public ComputeShader _marchingCubesShader;
    public ComputeShader _perlinNoiseComputeShader;
    public ComputeShader _normalsComputeShader;
    public ComputeShader _clearBuffer;
    
    public float _terraformStrength;
    
    private ComputeBuffer _densityMap;
    private ComputeBuffer _meshBuffer;
    private RenderTexture _normalsBuffer;
    public Material _drawBuffer;

    private GPUPerlinNoise _perlin;
    
    void Start()
    {
        // TODO use individual size for dimensions, is already considered in the marching cubes shader
        _densityMap = new ComputeBuffer(N * N * N, sizeof(float));

        //Holds the normals of the voxels
        _normalsBuffer = new RenderTexture(N, N, 0, RenderTextureFormat.ARGBHalf, RenderTextureReadWrite.Linear);
        _normalsBuffer.dimension = TextureDimension.Tex3D;
        _normalsBuffer.enableRandomWrite = true;
        _normalsBuffer.useMipMap = false;
        _normalsBuffer.volumeDepth = N;
        _normalsBuffer.Create();

        //Holds the verts generated by the marching cubes
        _meshBuffer = new ComputeBuffer(SIZE, sizeof(float) * 7);
        
        // initialize the buffer with -1's
        ClearBuffer();

        // TODO remove the perlin noise here and load a terrain or create s.t. more flat
        //Make the perlin noise, make sure to load resources to match shader used
        _perlin = new GPUPerlinNoise(_seed);
        _perlin.LoadResourcesFor3DNoise();
        
        _perlinNoiseComputeShader.SetInt("_Width", N);
        _perlinNoiseComputeShader.SetInt("_Height", N);
        _perlinNoiseComputeShader.SetFloat("_Frequency", 0.02f);
        _perlinNoiseComputeShader.SetFloat("_Lacunarity", 2.0f);
        _perlinNoiseComputeShader.SetFloat("_Gain", 0.5f);
        _perlinNoiseComputeShader.SetTexture(0, "_PermTable2D", _perlin.PermutationTable2D);
        _perlinNoiseComputeShader.SetTexture(0, "_Gradient3D", _perlin.Gradient3D);
        _perlinNoiseComputeShader.SetBuffer(0, "_Result", _densityMap);
        
        _perlinNoiseComputeShader.Dispatch(0, N / NUM_OF_THREADS, N / NUM_OF_THREADS, N / NUM_OF_THREADS);

        // calculates the implicit geometry
        UpdateImplicitGeomentry();

        // when a explicit geometry is needed use readBackMesh
        //ReadBackMesh(_meshBuffer);
    }

    private void Update()
    {
        if(Input.GetMouseButton(0))
        {
            AlterateTerrain(_terraformStrength * Time.deltaTime);
        }
        else if(Input.GetMouseButton(1))
        {
            AlterateTerrain(-_terraformStrength * Time.deltaTime);
        }
    }

    void OnRenderObject()
    {
        //Since mesh is in a buffer need to use DrawProcedual called from OnPostRender
        _drawBuffer.SetBuffer("_Buffer", _meshBuffer);
        _drawBuffer.SetPass(0);

        Graphics.DrawProceduralNow(MeshTopology.Triangles, SIZE);
    }

    void OnDestroy()
    {
        // MUST release buffers.
        _densityMap.Release();
        _meshBuffer.Release();
        _normalsBuffer.Release();
    }

    private void UpdateImplicitGeomentry()
    {
        // TODO check whether this makes sense performance wise. The whole procedure together with creating a 
        // buffer as big as the whole volume potentially only sparsly set with triangles, the marching cubes could also
        // output triangles instead
        ClearBuffer();
        ComputeNormals();
        ComputeImplicitGeometry();
    }

    public void ClearBuffer()
    {
        _clearBuffer.SetInt("_Width", N);
        _clearBuffer.SetInt("_Height", N);
        _clearBuffer.SetInt("_Depth", N);
        _clearBuffer.SetBuffer(0, "_Buffer", _meshBuffer);

        _clearBuffer.Dispatch(0, N / 8, N / 8, N / 8);
    }

    private void ComputeNormals()
    {
        _normalsComputeShader.SetInt("_Width", N);
        _normalsComputeShader.SetInt("_Height", N);
        _normalsComputeShader.SetBuffer(0, "_Noise", _densityMap);
        _normalsComputeShader.SetTexture(0, "_Result", _normalsBuffer);

        _normalsComputeShader.Dispatch(0, N / 8, N / 8, N / 8);
    }

    private void ComputeImplicitGeometry()
    {
        // make the mesh verts
        float[] dim = new float[] {N, N, N};
        _marchingCubesShader.SetFloats("_dimensions", dim);
        _marchingCubesShader.SetFloat("_densityThreshold", 0.0f);
        _marchingCubesShader.SetBuffer(0, "_voxelDensities", _densityMap);
        _marchingCubesShader.SetTexture(0, "_normals", _normalsBuffer);
        _marchingCubesShader.SetBuffer(0, "_vertexBuffer", _meshBuffer);

        _marchingCubesShader.Dispatch(0, N / NUM_OF_THREADS, N / NUM_OF_THREADS, N / NUM_OF_THREADS);
    }

    private void AlterateTerrain(float val)
    {
        Vector3 spherePos = Camera.main.transform.GetChild(0).position;
        
        // Note: there is a y, z offset somewhere I did not found so far, it is recognized here
        int xPos = (int) spherePos.x + N / 2;
        int yPos = (int) spherePos.y;
        int zPos = (int) spherePos.z + N / 2;
        int index = xPos + ( yPos * N ) + ( zPos * N *  N);

        // in case the calculated index lies within the volume...
        if (index >= 0 && index < N * N * N)
        {
            // ... get all the data
            // TODO this whole procedure does not sound that efficient at all but maybe it is easy to sync?
            float[] data = new float[N*N*N];
            _densityMap.GetData(data);
            
            // do this just for the half as the middle point is visited later again with the neighbours
            data[index] += val/2;

            // alterate all the neighbours as well
            // TODO maybe do it more sensible, sphere like? But not important for now
            for (int i = -1; i < 2; ++i)
            {
                for (int j = -1; j < 2; ++j)
                {
                    for (int k = -1; k < 2; ++k)
                    {
                        index = (xPos + i) + ( (yPos + j) * N ) + ( (zPos + k) * N *  N);
                        if (index >= 0 && index < N * N * N)
                        {
                            data[index] += val/2;
                        }
                    }
                }
            }
            _densityMap.SetData(data);
            UpdateImplicitGeomentry();
        }
    }

    struct Vertex
    {
        public Vector4 position;
        public Vector3 normal;
    };

  
    // Reads back the mesh data from the GPU and turns it into a standard unity mesh.
    List<GameObject> ReadBackMesh(ComputeBuffer meshBuffer)
    {
        //Get the data out of the buffer.
        Vertex[] verts = new Vertex[SIZE];
        meshBuffer.GetData(verts);

        //Extract the positions, normals and indexes.
        List<Vector3> positions = new List<Vector3>();
        List<Vector3> normals = new List<Vector3>();
        List<int> index = new List<int>();

        List<GameObject> objects = new List<GameObject>();

        int idx = 0;
        for (int i = 0; i < SIZE; i++)
        {
            //If the marching cubes generated a vert for this index
            //then the position w value will be 1, not -1.
            if (verts[i].position.w != -1)
            {
                positions.Add(verts[i].position);
                normals.Add(verts[i].normal);
                index.Add(idx++);
            }

            int maxTriangles = 65000 / 3;

            if(idx >= maxTriangles)
            {
                objects.Add(MakeGameObject(positions, normals, index));
                idx = 0;
                positions.Clear();
                normals.Clear();
                index.Clear();
            }
        }

        return objects;
    }

    GameObject MakeGameObject(List<Vector3> positions, List<Vector3> normals, List<int> index)
    {
        Mesh mesh = new Mesh();
        mesh.vertices = positions.ToArray();
        mesh.normals = normals.ToArray();
        mesh.bounds = new Bounds(new Vector3(0, N / 2, 0), new Vector3(N, N, N));
        mesh.SetTriangles(index.ToArray(), 0);

        GameObject go = new GameObject("Voxel Mesh");
        go.AddComponent<MeshFilter>();
        go.AddComponent<MeshRenderer>();
        go.GetComponent<Renderer>().material = new Material(Shader.Find("Standard"));
        go.GetComponent<MeshFilter>().mesh = mesh;
        go.isStatic = true;

        MeshCollider collider = go.AddComponent<MeshCollider>();
        collider.sharedMesh = mesh;

        go.transform.parent = transform;

        //Draw mesh next too the one draw procedurally.
        go.transform.localPosition = new Vector3(N + 2, 0, 0);

        return go;
    }
}

    

